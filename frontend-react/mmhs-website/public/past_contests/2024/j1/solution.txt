#include <iostream>
#include <algorithm>
#include <vector>
#include <cstring>

using namespace std;


int n;
int dp[201][201];

//interval dp
//what should the state be?
//dp[l][r] max score obtainable for subarray l to r
//what should transition be? a little tricky.
//take each number from l to r
//say we have 1 2 4 3
//if we take the 2, our score is 1 + 2 + 3 + ans of [1, 4, 3] = 6 + 8 = 14
//take 4, our score is 2 + 4 + 3 + ans of [1, 2, 3] = 9 + 6 = 15
//we know for an interval for sure we will get the leftmost and rightmost elemenets in the score
//instead of iterating through pop points we go through
//last to be taken then we can merge our subproblems


void solve(int arr[]) {
    memset(dp, 0, sizeof dp);

    for (int intervalSize = 2; intervalSize <= n; intervalSize++) {
        for (int l = 0; l < n-intervalSize; l++) {
            int r = l + intervalSize;
            int score = 0;
            for (int i = l+1; i < r; i++) {
                int newScore = dp[l][i] + arr[l]+arr[i]+arr[r] + dp[i][r]; 
                score = max(score, newScore);
            }
            dp[l][r] = score;
        }
    }
    cout << dp[0][n-1] << endl;
}


int main() {
    while (true) {
        cin >> n;
        if (n == 0) break;
        int arr[201];
        for (int i=0; i<n; i++) cin >> arr[i];
        solve(arr);
    }
}